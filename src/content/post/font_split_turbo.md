---
title: 字体分包性能优化
description: 这篇文章将介绍 cn-font-split 在 4.0 版本中的各项性能优化
article:
    authors:
        - 江夏尧
    section: 技术内幕
    tags:
        - 性能优化
    pubDate: 2023-5-23
    image: 'https://ik.imagekit.io/chinesefonts/tr:w-1200/image/photo-1508804185872-d7badad00f7d.jfif'
---

# 字体分包性能优化

在 4.0 版本中，我们采用了多线程和基于 WebAssembly 的插件，使得我们的分包时间从原先的 19s 缩减到了 5s，这可以说是一个巨大的性能优化了，那么我们是如何实现这一点的呢？

## 使用 Harfbuzz（WASM） 替换 Javascript 字体打包库

在 3.0 版本中，我们使用 Javascript 插件 fonteditor-core 进行字体文件的解析，这是一个缓慢的过程，解析过程中遇到特殊的字体情况还会导致某些 BUG。于是我们在 Github 社区中搜寻一个兼顾性能、专业性和兼容性的解决方案。

于是，我们找到了 Harfbuzz 项目，一个使用 C++ 编写、用于在各个平台中解析字体文件并进行渲染的开源仓库。Harfbuzz 的 Wasm 版本在 cn-font-split 中起到了解析字体文件、获取字体中 unicode 覆盖范围、直接生成分包文件的作用，是 cn-font-split 最核心的一个插件。

该项目提供了一个 Wasm 打包成品，其中有 subset 功能分包，但是 JS binding 却是人工编写的，TS 类型也缺失较多。所以我们对其进行了二次封装，把 Wasm 导出的 API 整合为了面向对象的一个库文件，这样在我们的项目中就可以轻松调用了。同时因为我们需要读取字体的某些属性，这些属性又没有在 subset 功能分包中进行导出，所以我们就直接修改了原始的项目（查看 C++ 代码看得头疼 😂），使得其能够兼容更多的功能。

## 多线程优化

在 4.0 版本中，为了保证程序最大的兼容性，仍然默认采用单线程的打包方式，你可以通过 `threads:{}` 直接开启多线程，打包速度直接飞升！

### 多线程为何那么快？

JS 多线程由多个 Worker 构成，由主线程的一个线程池进行生成、运作和销毁的功能。

1. 每个 Worker 持有相同的代码，并且 Worker 中还可以使用 WebAssembly；
2. 每个线程单独运行，不阻塞主线程；
3. 每个线程将会被分配到独立 CPU 中进行计算，可以最大化利用多核心优势。

拥有这些优点之后，只需要将长时间、重计算类的函数分配到 Worker 线程中，那么就可以在多核情况下，同时进行多个耗时任务，总时间就少了。

### 多线程在项目中优化了哪一部分？

首先，在单线程版本中，我们观察到了 woff2 库将 ttf 字体压缩为 woff2 字体的速度是非常慢的，大约需要 500ms 一次，而解析分包只需要 5ms 一次 😂。所以这个压缩过程在单线程中是非常耗时而且串行的，最终导致的后果就是大量时间被消耗了。

所以我们将这部分代码直接内置在了 Worker 线程中，并通过 workerpool 库的封装，逻辑上简化为一个函数交给主线程使用。在主线程中直接申请一次调用，并传入二进制数据即可实现多线程调用。workerpool 帮你实现了自动分配线程、通信数据封装、自动销毁线程等操作，剩下的时间可以休息一下 🍻。

代码中有些小细节，我们使用 transferable 的方式**转移二进制**，而非默认的**拷贝二进制**。因为主线程中，这个 ttf 文件的数据不再需要了，可以转移；同时，线程中产生的结果二进制也是不被内部需要的，也可以进行转移。二进制数据直接通过转移的手法可以节省一部分的内存，避免极端情况下内存不足的尴尬。

### 多线程有趣的点

1. 多线程不一定比单线程快：我曾经对那个 5ms 的函数进行了多线程封装，结果发现创建线程和线程数据传输总时间达到了 1.5s 一次 😂。
2. 多线程数据传回主线程会阻塞：多线程运行不会阻塞，返回的数据会阻塞。你的主线程只有一个，一旦在极短时间内返回大量数据，还是并发，主线程仍然没法快速处理，需要一个一个串行解决，这样就导致了多线程比单线程还耗时。
3. Javascript 在浏览器中的内存共享方案 SharedArrayBuffer 需要特殊的 CORS 设置，所以出于兼容性考虑，我们并没有使用它。
4. 浏览器中创建 worker 需要严格的同源策略，不允许 worker 脚本本身是跨域的；但是 worker 的 `importScripts`、`import ` 却可以导入跨域脚本，所以我们在浏览器的兼容上多封装了一层。
